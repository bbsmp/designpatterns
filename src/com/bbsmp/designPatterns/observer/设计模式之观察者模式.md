## 观察者模式
> 一、定义

定义对象间一对多的依赖关系。当一个对象的状态改变时，所有依赖于它的对象都将得到通知并自动更新。观察者模式=发布者 + 订阅者。

> 二、使用场景

* 关联行为场景
    * 当一个抽象模型有两个方面，其中一个方面依赖于另一个方面。将这两者封装在独立的对象中以使它们各自独立地改变和复用。
* 事件多级触发场景
    * 当一个对象的改变需要同时改变其他对象，而不知道具体有多少个对象有待改变。
* 跨系统的消息交换场景
* 当一个对象必须通知其他对象，而又不能假定其他对象是谁。换言之，你不希望这些对象是紧密耦合的。

> 三、设计原则

* 为了交互对象间的松耦合设计而努力

> 四、类图与参与者

![观察者模式类图](http://pic002.cnblogs.com/images/2012/155937/2012071215463875.png)

**参与者：**

* **Subject(目标，发布者)：**
    * 目标知道它的观察者。可以有任意多个观察者观察同一个目标。
    * 提供注册和删除观察者对象的接口。
* **Observer(观察者)：**
    *  为那些当目标改变时需要获得通知的对象定义一个接口。
* **ConcreteSubject(具体目标)**
    * 将有关的状态存入各ConcreteSubject对象。
    * 当它的状态发生改变时，向它的各个观察者发出通知。
* **ConcreteObserver(具体关键字)**
    * 维护一个指向ConcreteSubject对象的引用。
    * 存储有关状态，这些状态与目标的状态保持一致。
    * 实现Observer的更新接口，以使自己的状态与目标状态保持一致。

> 五、观察者模式的优缺点

观察者模式主要用于对象间的解耦，将观察者与被观察完全隔离。只依赖于Observer和Subject(Observable)抽象。可以单独服用目标对象而无需同时复用其观察者，反之亦然。而且允许在不改动目标和其他观察者的前提下增加观察者。

* **优点**
    * **目标和观察者之间的抽象耦合。**目标只知道它有一些列的观察者，它们实现了observer接口，但不知道观察者的具体类型。 这样目标和观察者间的耦合度低。
    * **支持广播通信。**
* **缺点**
    * **可能导致意外更新**  一个观察者并不知道其他的观察者，他并不确切知道更改目标状态的代价。可能一个看起来无害的目标更新，将引起其他观察者的状态改变。如果依赖准则的定义或维护不恰当，常常会引起错误更新。

