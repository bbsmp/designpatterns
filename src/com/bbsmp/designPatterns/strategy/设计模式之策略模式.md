## 设计模式之策略模式

> 一、定义 

####    策略模式定义了一系列的算法，并将每个算法封装起来，而且还使它们可以相互替换。策略模式让算法独立于使用它们的客户端而独立变化。

> 二、使用场景

1. 针对同一类型的多种处理方式，仅仅是具体行为有差异
2. 需要安全地封装多种同一类型的操作时。
3. 出现同一抽象类有多个子类，而又要使用if-else或者switch-case来选择具体子类时。

> 三、设计原则

1. 找出应用中可能需要变化之处，把它们独立出来，不要和那些不需要变化的代码混在一起。
2. 针对接口编程，而不是针对实现编程
    * 针对接口编程，“接口”是广义的，可以在不使用接口的情况下，进行“针对接口编程”，关键在于利用面向对象的“多态特性”。针对接口编程，即是针对超类型编程。“变量的申明类型应该是超类型，如此，只要是具体实现此超类型的类所产生的对象，都可以指定给这个变量。这也意味着，声明类型时不用考虑以后执行的真正对象类型。”
3. 多用组合，少用继承


> 四、策略模式的类图与参与者

![策略模式类图](http://pic002.cnblogs.com/images/2012/155937/2012070310013466.png)

* Strategy:策略的抽象
    定义所有支持算法的公用接口。Context用这个接口来调用ConcreteStrategy定义的算法。
* ConcreteStrategy:具体策略
    实现了Strategy接口的具体算法
* Context：上下文
    用一个ConcreteStrategy对象来配置
    维护一个队Strategy对象的引用
    可定义一个接口来让Strategy访问他的数据。


> 五、策略模式的优缺点

策略模式主要用来分离算法，在相同的行为抽象下有不同的具体实现策略。这个模式很好地演示了开闭原则，也就是定义抽象、注入不同的实现，从而大道很好的可扩展性。

* 优点
1.结构清晰明了，使用简单直观；
2.耦合度相对较低，扩展方便；
3.操作封装更为彻底，数据更为安全（代替了继承）；
* 缺点
1.随着策略的增加，子类变得繁多。
2.客户必须了解不同的Strategy。
    3.Strategy与Context之间的通信开销。无论各具体策略实现的算法是简单还是复杂，它们都共享Strategy定义的接口。因此很可能某些ConcreteStrategy不会都用到所有通过这个接口传递给她们的信息；简单的ConcreteStrategy可能不使用其中的任何信息，这意味着有时Context会创建和初始化一些永远不会用到的参数。如果存在这样的问题，那么将在strategy和context之间进行紧密耦合。

> 六、Android源码中的策略模式

